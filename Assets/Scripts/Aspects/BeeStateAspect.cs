using Assets.Scripts.Buffers;
using Assets.Scripts.Components;
using Unity.Burst;
using Unity.Entities;
using Unity.Mathematics;
using Unity.Physics;
using Unity.Transforms;
using UnityEngine;
using Collider = Unity.Physics.Collider;
using SphereCollider = Unity.Physics.SphereCollider;

[BurstCompile]
public readonly partial struct BeeStateAspect : IAspect
{
    public readonly Entity Entity;
    public readonly RefRW<LocalTransform> LocalTransform;
    public readonly RefRW<BeeStateComponent> BeeState;
    public readonly RefRW<BeeFlowerScanComponent> FlowerScan;
    public readonly RefRW<GoalPositionComponent> GoalPosition;
    public readonly RefRO<BeeSpeedComponent> BeeSpeed;
    public readonly RefRW<RandomComponent> RandomComp;
    public readonly RefRW<ChunkPositionComponent> ChunkPosition;
    public readonly RefRO<BeeSightComponent> BeeSight;
    public readonly RefRW<BeeNestComponent> BeeNest;
    public readonly RefRW<BeePolenSourceComponent> BeePolenSource;
    //public readonly RefRW<AnimationStateComponent> AnimationState;
    public readonly RefRO<PhysicsDataComponent> BeePhysicsCollider;
    public readonly RefRW<SoundEmitter> SoundEmitter;
    
    [BurstCompile]
    public void Forage(float deltaTime, EntityCommandBuffer.ParallelWriter ecb, int sortKey, Entity bufferHolder)
    {
        if (math.distancesq(LocalTransform.ValueRO.Position, GoalPosition.ValueRO.Position) <= 4)
        {
            // Goal position reached, change to new goal position
            // Lévy flight: https://en.wikipedia.org/wiki/L%C3%A9vy_flight
            // Goal position will be generated by two random angles and a step. This step length will be calculated by a random number with a probability distribution
            // Pitch
            float pitch = RandomComp.ValueRW.Random.NextFloat(-Globals.BEE_MAX_FORAGING_PITCH_ANGLE, Globals.BEE_MAX_FORAGING_PITCH_ANGLE);
            // Yaw
            float yaw = RandomComp.ValueRW.Random.NextFloat(-Globals.BEE_MAX_FORAGING_YAW_ANGLE_BIASED, Globals.BEE_MAX_FORAGING_YAW_ANGLE_BIASED);
            // Step
            float stepProbability = RandomComp.ValueRW.Random.NextFloat(0, 1);
            float finalStep = 0;
            for (int p = 0; p < Globals.BEE_FORAGING_STEPS_PROBABILITIES.Length - 1; p++)
            {
                if (stepProbability >= Globals.BEE_FORAGING_STEPS_PROBABILITIES[p] && stepProbability < Globals.BEE_FORAGING_STEPS_PROBABILITIES[p + 1])
                {
                    // In range
                    finalStep = RandomComp.ValueRW.Random.NextFloat(Globals.BEE_FORAGING_STEPS[p], Globals.BEE_FORAGING_STEPS[p + 1]);
                    break;
                }
            }
            float3 forward = math.normalize(LocalTransform.ValueRO.Forward());
            //float3 forward = float3.zero;
            // TODO: the new goal position should be biased depending in various factors
            // - Other bees in the surroundings. Go to the direction with less density
            // - Known dangers
            GoalPosition.ValueRW.Position.x = finalStep * (math.cos(yaw) + forward.x) + LocalTransform.ValueRO.Position.x;
            //GoalPosition.ValueRW.Position.y = math.sin(pitch) + forward.y + LocalTransform.ValueRO.Position.y;
            GoalPosition.ValueRW.Position.z = finalStep * (math.sin(-yaw) + forward.z) + LocalTransform.ValueRO.Position.z;
            GoalPosition.ValueRW.Position = math.clamp(GoalPosition.ValueRO.Position, float3.zero, new float3(Globals.CHUNK_SIZE * Globals.WORLD_SIZE, 100, Globals.CHUNK_SIZE * Globals.WORLD_SIZE));
            ecb.AppendToBuffer<HeightWorldBufferElement>(sortKey, bufferHolder, new HeightWorldBufferElement { Requester = Entity });
            LookAt(GoalPosition.ValueRW.Position, deltaTime);

            // Bee must scan surroundings before continuing exploration
            ChangeState(BeeStates.SCANNING, ecb, sortKey);
        }
        else
        {
            // Check energy levels
            if (BeeState.ValueRO.Energy <= 0)
            {
                if (math.distancesq(LocalTransform.ValueRO.Position, BeeNest.ValueRO.NestPosition) <= 1)
                {
                    // Get inside and rest
                    SetToRest(ecb, sortKey);
                }
                else
                {
                    // Bee has to get back to nest
                    MoveTo(BeeNest.ValueRO.NestPosition, deltaTime);
                    LookAt(BeeNest.ValueRO.NestPosition, deltaTime);
                }
                return;
            }

            /*
            // Check if it's near the nest, if it's near, look if any bee is dancing
            if (math.distancesq(LocalTransform.ValueRO.Position, BeeNest.ValueRO.NestPosition) <= 20)
            {
                // Get closest bee dancing
                BeeDanceInformation dance = BeeNest.ValueRO.NestState.ValueRO.GetClosestDanceInfo(LocalTransform.ValueRO.Position);
                if (dance.DanceType != Dances.NONE)
                {
                    GoalPosition.ValueRW.Position = dance.DanceMessage;
                    // TODO: LOOK AT BEE
                    BeeState.ValueRW.State = BeeStates.WATCHING;
                    return;
                }
            }*/

            // Bee has a goal position to reach
            MoveTo(GoalPosition.ValueRO.Position, deltaTime);
            
            int2 currentChunkCoord = BeeWorld.WorldToChunk(LocalTransform.ValueRO.Position);
            if (!currentChunkCoord.Equals(ChunkPosition.ValueRO.Coord))
            {
                // Chunk has changed
                // Scan surroundings searching for pollen source
                ChangeState(BeeStates.SCANNING, ecb, sortKey);
                ChunkPosition.ValueRW.Coord = currentChunkCoord;
            }
        }
    }

    public void HandleLifeStats(float deltaTime, EntityCommandBuffer.ParallelWriter ecb, int sortKey)
    {

        BeeState.ValueRW.Age += deltaTime;
        if (BeeState.ValueRO.State != BeeStates.GROWING)
        {
            BeeState.ValueRW.Energy -= deltaTime;
            BeeState.ValueRW.Carbohydrates -= deltaTime * Globals.CARBS_CONSUMPTION_PER_SECOND;
            BeeState.ValueRW.Protein -= deltaTime * Globals.PROTEIN_CONSUMPTION_PER_SECOND;
            BeeState.ValueRW.Fats -= deltaTime * Globals.FATS_CONSUMPTION_PER_SECOND;
            if (BeeState.ValueRO.Carbohydrates <= 0)
            {
                if (BeeState.ValueRO.NectarTaken > 0)
                {
                    float nectarEaten = math.min(BeeState.ValueRO.NectarTaken, Globals.MAX_POLLEN_CONSUMPTION);
                    BeeState.ValueRW.Carbohydrates = nectarEaten * 0.7f;
                    BeeState.ValueRW.NectarTaken -= (int)nectarEaten;
                }
            }

            bool isStressing = false;
            if (BeeState.ValueRW.Energy <= 0)
            {
                BeeState.ValueRW.TimeWithoutEnergy += deltaTime;
                isStressing = true;
            } else
            {
                BeeState.ValueRW.TimeWithoutEnergy = 0;
            }
            if (BeeState.ValueRO.Protein <= 0 || BeeState.ValueRO.Carbohydrates <= 0 || BeeState.ValueRO.Fats <= 0)
            {
                BeeState.ValueRW.TimeWithoutFood += deltaTime;
                isStressing = true;
            } else
            {
                BeeState.ValueRW.TimeWithoutFood = 0;
            }

            if(isStressing)
            {
                BeeState.ValueRW.Stress += deltaTime * math.lerp(Globals.STRESS_INCREMENT_MIN, Globals.STRESS_INCREMENT_MAX, BeeState.ValueRO.TimeWithoutEnergy / 30)
                    * math.lerp(Globals.STRESS_INCREMENT_MIN, Globals.STRESS_INCREMENT_MAX, BeeState.ValueRO.TimeWithoutFood / 60)
                    * math.lerp(Globals.STRESS_INCREMENT_MIN, Globals.STRESS_INCREMENT_MAX, BeeState.ValueRO.Age / Globals.MAX_LIFE_EXPECTANCY);
            } else
            {
                BeeState.ValueRW.Stress = math.max(BeeState.ValueRW.Stress - (deltaTime * 0.5f), 0);
            }

            BeeState.ValueRW.LifeLeftToDie -= deltaTime * (BeeState.ValueRW.Energy <= 0 ? (Globals.LIFE_DECREMENT_FACTOR_WHEN_TIRED) : 1);

            if (BeeState.ValueRO.Stress >= Globals.MAX_STRESS_TO_DIE)
            {
                Die(ecb, sortKey);
            }
        }
    }

    private void ChangeState(BeeStates state, EntityCommandBuffer.ParallelWriter ecb, int sortKey)
    {
        BeeState.ValueRW.State = state;
        SoundEmitter.ValueRW.Pitch = 1; // TODO: Change pitch
        switch(state)
        {
            case BeeStates.FORAGING:
                SoundEmitter.ValueRW.Pitch = RandomComp.ValueRW.Random.NextFloat(0.9f,1.1f);
                break;
            case BeeStates.COLLECTING:
                SoundEmitter.ValueRW.Pitch = RandomComp.ValueRW.Random.NextFloat(1.2f, 1.5f);
                break;
            case BeeStates.SCANNING:
                FlowerScan.ValueRW.FlowerId = -1;
                ecb.AppendToBuffer<ScanRequest>(sortKey, BeeNest.ValueRO.NestEntity, new ScanRequest { Requester = Entity, BeePosition = LocalTransform.ValueRO.Position, FlowerType=0 });
                SoundEmitter.ValueRW.Pitch = RandomComp.ValueRW.Random.NextFloat(0.9f, 1.1f);
                break;
            case BeeStates.DANCING:
                SoundEmitter.ValueRW.Pitch = RandomComp.ValueRW.Random.NextFloat(0.7f, 0.9f);
                break;
            case BeeStates.RESTING:
                SoundEmitter.ValueRW.Pitch = RandomComp.ValueRW.Random.NextFloat(0);
                break;
            case BeeStates.RECOLLECTING:
                SoundEmitter.ValueRW.Pitch = RandomComp.ValueRW.Random.NextFloat(0.9f, 1.1f);
                break;
            case BeeStates.WATCHING:
                SoundEmitter.ValueRW.Pitch = RandomComp.ValueRW.Random.NextFloat(0.9f, 1.1f);
                break;
        }
    }

    [BurstCompile]
    public void Scan(float deltaTime, PhysicsWorldSingleton physicsWorld, EntityCommandBuffer.ParallelWriter ecb, int sortKey)
    {
        if(FlowerScan.ValueRO.FlowerId==-1)
        {
            // Not answered yet
            return;
        } else if(FlowerScan.ValueRO.FlowerId == -2 || FlowerScan.ValueRO.FlowerId == -3)
        {
            // No flower found
            ChangeState(BeeStates.FORAGING, ecb, sortKey);
            return;
        }
        GoalPosition.ValueRW.Position = FlowerScan.ValueRO.FlowerPosition;
        LookAt(GoalPosition.ValueRO.Position, deltaTime);
        ChangeState(BeeStates.RECOLLECTING, ecb, sortKey);

        /*
        ClosestHitCollector<DistanceHit> closestHitCollector = new ClosestHitCollector<DistanceHit>(BeeSight.ValueRO.SightRange);
        //Debug.Log(Entity.Index +": " + col.BelongsTo + ", " + col.CollidesWith);
        if (physicsWorld.OverlapSphereCustom(LocalTransform.ValueRO.Position, BeeSight.ValueRO.SightRange, ref closestHitCollector, BeePhysicsCollider.ValueRO.CollisionFilter))
        {
            if(closestHitCollector.ClosestHit.Entity.Equals(BeePolenSource.ValueRO.PolenSourceEntity))
            {
                // If it's the same, continue exploring
                BeeState.ValueRW.State = BeeStates.FORAGING;
            } else
            {
                // Save polen source
                Entity polenSource = closestHitCollector.ClosestHit.Entity;
                BeePolenSource.ValueRW.PolenSourceEntity = polenSource;
                // Position of pollen source
                GoalPosition.ValueRW.Position = closestHitCollector.ClosestHit.Position;
                //Debug.Log("Polen source Position: " + GoalPosition.ValueRO.Position);
                LookAt(GoalPosition.ValueRO.Position, deltaTime);

                // Set state to Recollecting
                ChangeState(BeeStates.RECOLLECTING);
            }
           
        } else
        {
            // Continue exploring
            ChangeState(BeeStates.FORAGING);
        }*/
    }

    [BurstCompile]
    public void Recollect(float deltaTime, EntityCommandBuffer.ParallelWriter ecb, int sortKey)
    {
        // Is the bee close to the source?
        // YES: Change state to COLLECT
        // NO: 
        //  DOES THE BEE HAVE NO ENERY OR IT'S ALREADY CARRYING POLLEN
        //      YES: GO NEST
        //      NO: GO TO POLEN SOURCE
        if (BeeState.ValueRO.Energy <= 0 || BeeState.ValueRO.PollenTaken > 0 || BeeState.ValueRO.NectarTaken > 0)
        {
            if (math.distancesq(LocalTransform.ValueRO.Position, BeeNest.ValueRO.NestPosition) <= 1)
            {
                // Get inside and rest
                SetToRest(ecb, sortKey);
            }
            else
            {
                // Bee has to get back to nest
                MoveTo(BeeNest.ValueRO.NestPosition, deltaTime);
                LookAt(BeeNest.ValueRO.NestPosition, deltaTime);
            }

        }
        else
        {
            // Is it close to the pollen source
            if (math.distancesq(LocalTransform.ValueRO.Position, GoalPosition.ValueRO.Position) < 0.025f)
            {
                // It's close, start collecting
                ChangeState(BeeStates.COLLECTING, ecb, sortKey);
            }
            else
            {
                // It's still far, go to the pollen source
                MoveTo(GoalPosition.ValueRO.Position, deltaTime);
            }
        }


    }

    [BurstCompile]
    public void Die(EntityCommandBuffer.ParallelWriter ecb, int sortKey)
    {
        // Spawn particles, etc.

        // "Kill" entity
        ecb.SetComponentEnabled<IsDead>(sortKey, Entity, true);
        ecb.AppendToBuffer<DeathRequest>(sortKey, BeeNest.ValueRO.NestEntity, new DeathRequest { DeadEntity = Entity });
        // Reset all components
        BeeState.ValueRW.State = BeeStates.DEAD;
        BeeState.ValueRW.LifeLeftToDie = Globals.MAX_LIFE_EXPECTANCY;
        BeeState.ValueRW.Age = 0;
        BeeState.ValueRW.Stress = 0;
        BeeState.ValueRW.TimeWithoutEnergy = 0;
        BeeState.ValueRW.TimeWithoutFood = 0;
        BeeState.ValueRW.PollenTaken = 0;
        BeeState.ValueRW.Protein = 0;
        BeeState.ValueRW.Carbohydrates = 0;
        BeeState.ValueRW.Fats = 0;
        BeeState.ValueRW.Energy = 0;
        LocalTransform.ValueRW.Scale = 0;
        LocalTransform.ValueRW.Translate(new float3(100000, 0, 100000));
        BeeState.ValueRW.StateBeforeResting = BeeStates.NONE;
        LocalTransform.ValueRW.Position = BeeNest.ValueRO.NestPosition;
        GoalPosition.ValueRW.Position = BeeNest.ValueRO.NestPosition;
        BeeState.ValueRW.TimeForAction = -1;
    }

    [BurstCompile]
    public void Collect(float deltaTime, EntityCommandBuffer.ParallelWriter ecb, int sortKey, Entity bufferHolder)
    {

        if (BeeState.ValueRO.TimeForAction < 0.0f)
        {
            // Just started collecting
            // Make a request
            ecb.AppendToBuffer<PolenRequestAtFlowerBufferElement>(sortKey, bufferHolder, 
                new PolenRequestAtFlowerBufferElement { Requester=Entity, FlowerId = FlowerScan.ValueRO.FlowerId, ChunkCoord = FlowerScan.ValueRO.ChunkCoord});
            BeeState.ValueRW.TimeForAction = RandomComp.ValueRW.Random.NextFloat(Globals.BEE_COLLECTION_MIN_TIME, Globals.BEE_COLLECTION_MAX_TIME);
            return;
        }
        else
        {
            // Simulating collection
            BeeState.ValueRW.TimeForAction -= deltaTime;

            if (BeeState.ValueRO.TimeForAction <= 0.0f)
            {
                // Collection has finished
                int polenTaken = BeePolenSource.ValueRO.PolenAnswered;
                int nectarTaken = BeePolenSource.ValueRO.NectarAnswered;
                BeePolenSource.ValueRW.PolenAnswered = -1;
                BeePolenSource.ValueRW.NectarAnswered = -1;
                if (polenTaken >= 0 || nectarTaken>=0)
                {
                    // Request got answered
                    if(polenTaken > 0 || nectarTaken>0)
                    {
                        // Some polen was taken
                        // Check if bee is hungry
                        /*
                        if (BeeState.ValueRO.Protein <= 0 || BeeState.ValueRO.Fats <= 0)
                        {

                            if(polenTaken>0)
                            {
                                float pollenEaten = math.min(polenTaken, Globals.MAX_POLLEN_CONSUMPTION);
                                BeeState.ValueRW.Protein = pollenEaten * 0.4f;
                                BeeState.ValueRW.Fats = pollenEaten * 0.3f;*
                                polenTaken -= (int)pollenEaten;
                            }
                        }*/
                        if(BeeState.ValueRO.Carbohydrates <= 0)
                        {
                            if (nectarTaken > 0)
                            {
                                float nectarEaten = math.min(nectarTaken, Globals.MAX_POLLEN_CONSUMPTION);
                                BeeState.ValueRW.Carbohydrates = nectarEaten * 0.7f;
                                nectarTaken -= (int)nectarEaten;
                            }
                        }
                        BeeState.ValueRW.PollenTaken += polenTaken;
                        BeeState.ValueRW.NectarTaken += nectarTaken;
                        ChangeState(BeeStates.RECOLLECTING, ecb, sortKey);
                    }
                    else
                    {
                        // No polen left, explore other sources
                        ChangeState(BeeStates.FORAGING, ecb, sortKey);
                        BeeState.ValueRW.TimeForAction = -1;
                    }
                }
                else
                {
                    // No answer yet, keep waiting
                    BeeState.ValueRW.TimeForAction = 1;
                }
            }
        }
    }


    [BurstCompile]
    public void Rest(float deltaTime, EntityCommandBuffer.ParallelWriter ecb, int sortKey, DynamicBuffer<BeeDanceInformation> beeDances)
    {
        // Simulating rest in nest/ time to deposit pollen
        if (BeeState.ValueRO.TimeForAction <= 0.0f)
        {
            // Has just got to base
            // TimeForAction in rest should check also if it's night time, if it's night time, the time for action should be the time of day - current
            BeeState.ValueRW.TimeForAction = RandomComp.ValueRW.Random.NextFloat(Globals.BEE_REST_MIN_TIME, Globals.BEE_REST_MAX_TIME);
            int pollenCollected = BeeState.ValueRO.PollenTaken;
            if (pollenCollected > 0)
            {
                ecb.AppendToBuffer<PolenRequest>(sortKey, BeeNest.ValueRO.NestEntity, new PolenRequest { Value = BeeState.ValueRO.PollenTaken, Requester = Entity, IsPollen =true });
                BeeState.ValueRW.PollenTaken = 0;
            }
            if(BeeState.ValueRO.NectarTaken > 0)
            {
                ecb.AppendToBuffer<PolenRequest>(sortKey, BeeNest.ValueRO.NestEntity, new PolenRequest { Value = BeeState.ValueRO.NectarTaken, Requester = Entity, IsPollen = false});
                BeeState.ValueRW.NectarTaken = 0;
            }

        }
        else
        {
            BeeState.ValueRW.TimeForAction -= deltaTime;
            // Already in base, just rest
            if (BeeState.ValueRO.TimeForAction <= 0.0f)
            {
                // Rested, go back to the action the bee was doing previously and get max energy
                if(BeeState.ValueRO.Energy <= 0 /* or it's night time*/)
                {
                    BeeState.ValueRW.Energy = Globals.BEE_MAX_ENERGY;
                    BeeState.ValueRW.TimeWithoutEnergy = 0;

                }
                
                // Eat
                if(BeeState.ValueRO.Fats <= 0 || BeeState.ValueRO.Protein <= 0)
                {
                    ecb.AppendToBuffer<PolenRequest>(sortKey, BeeNest.ValueRO.NestEntity, new PolenRequest { Value = -Globals.MAX_POLLEN_CONSUMPTION, Requester = Entity, IsPollen = true });
                }
                if(BeeState.ValueRO.Carbohydrates <= 0)
                {
                    ecb.AppendToBuffer<PolenRequest>(sortKey, BeeNest.ValueRO.NestEntity, new PolenRequest { Value = -Globals.MAX_POLLEN_CONSUMPTION, Requester = Entity, IsPollen = false });
                }
                LookAt(GoalPosition.ValueRO.Position, deltaTime);
                // Check if it has a polen source or not
                if (BeeState.ValueRO.StateBeforeResting == BeeStates.RECOLLECTING)
                {
                    // The bee has a polen source, it can provide info. to others dancing
                    ChangeState(BeeStates.DANCING, ecb, sortKey);
                } else
                {
                    // It's not recollecting
                    if(beeDances.Length>0)
                    {
                        // There are bees around dancing, watch one to get info.
                        ChangeState(BeeStates.WATCHING, ecb, sortKey);

                        // Store info.
                        int randomIndexToWatch = RandomComp.ValueRW.Random.NextInt(0, beeDances.Length);
                        BeeDanceInformation beeDance = beeDances[randomIndexToWatch];
                        if (beeDance.DanceType == Dances.POLEN_SOURCE)
                        {
                            GoalPosition.ValueRW.Position = beeDance.DanceMessage;
                            // Look at the entity
                            LookAt(beeDance.EntityPosition, deltaTime);
                        }
                        
                    } else
                    {
                        // It's not recollectingand there are no bees near that are dancing, continue what the bee was doing
                        BeeState.ValueRW.State = BeeState.ValueRO.StateBeforeResting;
                    }
                    
                }
                LocalTransform.ValueRW = LocalTransform.ValueRO.Translate(new float3(RandomComp.ValueRW.Random.NextFloat(-2, 2), 0, RandomComp.ValueRW.Random.NextFloat(-2, 2)));
                LocalTransform.ValueRW.Scale = 1;
                BeeState.ValueRW.TimeForAction = -1;
            }
        }
    }

    public void SetToRest(EntityCommandBuffer.ParallelWriter ecb, int sortKey)
    {
        // Set to invisible
        LocalTransform.ValueRW.Scale = 0;
        // Change states
        BeeState.ValueRW.StateBeforeResting = BeeState.ValueRO.State;
        ChangeState(BeeStates.RESTING, ecb, sortKey);
    }
    
    [BurstCompile]
    public void Dance(float deltaTime, EntityCommandBuffer.ParallelWriter ecb, int sortKey)
    {
        if (BeeState.ValueRO.TimeForAction <= 0.0f)
        {
            // Just started to dance, subscribe and start dancing
            ecb.AppendToBuffer(sortKey, BeeNest.ValueRO.NestEntity, new BeeDanceInformation { EntityId = Entity.Index, EntityPosition = LocalTransform.ValueRO.Position,
                DanceMessage = GoalPosition.ValueRO.Position, DanceType = Dances.POLEN_SOURCE});
            BeeState.ValueRW.TimeForAction = RandomComp.ValueRW.Random.NextFloat(Globals.BEE_DANCE_MIN_TIME, Globals.BEE_DANCE_MAX_TIME);
        }
        else
        {
            BeeState.ValueRW.TimeForAction -= deltaTime;
            if (BeeState.ValueRO.TimeForAction <= 0.0f)
            {
                // Bee finished dancing
                // Unsubscribe from dance buffer
                ecb.AppendToBuffer(sortKey, BeeNest.ValueRO.NestEntity, new DanceUnsubscription { EntityId = Entity.Index });
                // Change its state to the task it was doing previously
                BeeState.ValueRW.State = BeeState.ValueRO.StateBeforeResting;
                BeeState.ValueRW.TimeForAction = -1;
            }
        }
    }
    [BurstCompile]
    public void Watch(float deltaTime, EntityCommandBuffer.ParallelWriter ecb, int sortKey)
    {
        if (BeeState.ValueRO.TimeForAction <= 0.0f)
        {
            // Just started to watch a dance
            BeeState.ValueRW.TimeForAction = RandomComp.ValueRW.Random.NextFloat(Globals.BEE_WATCH_MIN_TIME, Globals.BEE_WATCH_MAX_TIME);

        }
        else
        {
            BeeState.ValueRW.TimeForAction -= deltaTime;
            if (BeeState.ValueRO.TimeForAction <= 0.0f)
            {
                // Just finished watching the dance
                ChangeState(BeeStates.FORAGING, ecb, sortKey);
                LookAt(GoalPosition.ValueRW.Position, deltaTime);
                BeeState.ValueRW.TimeForAction = -1;
            }
            else
            {
                // It's watching the dance, do nothing?
            }
        }
    }

    [BurstCompile]
    public void Grow(float deltaTime, EntityCommandBuffer.ParallelWriter ecb, int sortKey)
    {
        if (BeeState.ValueRO.TimeForAction <= 0.0f)
        {
            // Just started to grow
            BeeState.ValueRW.TimeForAction = Globals.TIME_TO_GROW;
        } else
        {
            BeeState.ValueRW.TimeForAction -= deltaTime;
            if (BeeState.ValueRO.TimeForAction <= 0.0f)
            {
                LocalTransform.ValueRW.Position = BeeNest.ValueRO.NestPosition;
                ChangeState(BeeStates.FORAGING, ecb, sortKey);
                BeeState.ValueRW.TimeForAction = -1;
            } else
            {
                BeeState.ValueRW.Carbohydrates -= deltaTime*Globals.LARVAE_CARBS_CONSUMPTION_PER_SECOND;
                BeeState.ValueRW.Protein -= deltaTime* Globals.LARVAE_PROTEIN_CONSUMPTION_PER_SECOND;
                BeeState.ValueRW.Fats -= deltaTime*Globals.LARVAE_FATS_CONSUMPTION_PER_SECOND;                
                if(BeeState.ValueRO.Carbohydrates > 0 && BeeState.ValueRO.Fats > 0 && BeeState.ValueRO.Protein > 0)
                {
                    BeeState.ValueRW.TimeWithoutFood = 0;
                } else
                {
                    if (BeeState.ValueRO.Carbohydrates <= 0 && BeeState.ValueRW.TimeWithoutFood == 0)
                    {
                        BeeState.ValueRW.TimeWithoutFood += deltaTime;
                        ecb.AppendToBuffer<PolenRequest>(sortKey, BeeNest.ValueRO.NestEntity, new PolenRequest { Value = -Globals.MAX_POLLEN_CONSUMPTION, Requester = Entity, IsPollen = false });
                    }
                    if ((BeeState.ValueRO.Fats <= 0 || BeeState.ValueRO.Protein <= 0) && BeeState.ValueRW.TimeWithoutFood == 0)
                    {
                        BeeState.ValueRW.TimeWithoutFood += deltaTime;
                        ecb.AppendToBuffer<PolenRequest>(sortKey, BeeNest.ValueRO.NestEntity, new PolenRequest { Value = -Globals.MAX_POLLEN_CONSUMPTION, Requester = Entity, IsPollen = true });
                    }
                }
                if(BeeState.ValueRO.TimeWithoutFood >= Globals.MAX_TIME_LARVAE_CAN_SURVIVE_WITHOUT_FOOD)
                {
                    Die(ecb, sortKey);
                }
            }
         }
    }


    /////////////////////////////////////////////////////
    /// UTILITY FUNCTIONS
    /////////////////////////////////////////////////////


    [BurstCompile]
    public void MoveTo(float3 destPos, float deltaTime)
    {
        float3 direction = destPos - LocalTransform.ValueRO.Position;
        float3 normalizedDirection = math.normalize(direction);
        LocalTransform.ValueRW = LocalTransform.ValueRO.Translate(normalizedDirection * BeeSpeed.ValueRO.Speed * deltaTime);
        LocalTransform.ValueRW = LocalTransform.ValueRO.WithRotation(GoalPosition.ValueRO.Rotation);
    }
    [BurstCompile]
    public void LookAt(float3 destPos, float deltaTime)
    {
        float3 direction = math.normalize(destPos - LocalTransform.ValueRO.Position);
        direction.y = 0;
        GoalPosition.ValueRW.Rotation = quaternion.LookRotation(direction, new float3(0, 1, 0));
    }
    public float3 GetQuaternionEulerAngles(quaternion rot)
    {
        float4 q1 = rot.value;
        float sqw = q1.w * q1.w;
        float sqx = q1.x * q1.x;
        float sqy = q1.y * q1.y;
        float sqz = q1.z * q1.z;
        float unit = sqx + sqy + sqz + sqw; // if normalized is one, otherwise is correction factor
        float test = q1.x * q1.w - q1.y * q1.z;
        float3 v;

        if (test > 0.4995f * unit)
        { // singularity at north pole
            v.y = 2f * math.atan2(q1.y, q1.x);
            v.x = math.PI / 2f;
            v.z = 0;
            return NormalizeAngles(v);
        }
        if (test < -0.4995f * unit)
        { // singularity at south pole
            v.y = -2f * math.atan2(q1.y, q1.x);
            v.x = -math.PI / 2;
            v.z = 0;
            return NormalizeAngles(v);
        }

        rot = new quaternion(q1.w, q1.z, q1.x, q1.y);
        v.y = math.atan2(2f * rot.value.x * rot.value.w + 2f * rot.value.y * rot.value.z, 1 - 2f * (rot.value.z * rot.value.z + rot.value.w * rot.value.w));     // Yaw
        v.x = math.asin(2f * (rot.value.x * rot.value.z - rot.value.w * rot.value.y));                             // Pitch
        v.z = math.atan2(2f * rot.value.x * rot.value.y + 2f * rot.value.z * rot.value.w, 1 - 2f * (rot.value.y * rot.value.y + rot.value.z * rot.value.z));      // Roll
        return NormalizeAngles(v);
    }

    public float3 NormalizeAngles(float3 angles)
    {
        angles.x = NormalizeAngle(angles.x);
        angles.y = NormalizeAngle(angles.y);
        angles.z = NormalizeAngle(angles.z);
        return angles;
    }

    public float NormalizeAngle(float angle)
    {
        while (angle > math.PI * 2f)
            angle -= math.PI * 2f;
        while (angle < 0)
            angle += math.PI * 2f;
        return angle;
    }

}
